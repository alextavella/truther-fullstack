/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * Truther API
 * Truther API Documentation
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import type {
  CreateUser201,
  CreateUserBody,
  GetCoinMarket200,
  GetCoinMarketParams,
  ListUsers200,
  ListUsersParams,
  SearchCoins200,
  SearchCoinsParams,
  UpdateUser200,
  UpdateUserBody,
} from './model'
import { customInstance } from '../lib/api'
import type { ErrorType, BodyType } from '../lib/api'

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

/**
 * Search coins
 * @summary Search coins
 */
export const searchCoins = (
  params: SearchCoinsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SearchCoins200>(
    { url: `/coins/search`, method: 'GET', params, signal },
    options,
  )
}

export const getSearchCoinsQueryKey = (params: SearchCoinsParams) => {
  return [`/coins/search`, ...(params ? [params] : [])] as const
}

export const getSearchCoinsQueryOptions = <
  TData = Awaited<ReturnType<typeof searchCoins>>,
  TError = ErrorType<unknown>,
>(
  params: SearchCoinsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof searchCoins>>,
      TError,
      TData
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSearchCoinsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchCoins>>> = ({
    signal,
  }) => searchCoins(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchCoins>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type SearchCoinsQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchCoins>>
>
export type SearchCoinsQueryError = ErrorType<unknown>

/**
 * @summary Search coins
 */

export function useSearchCoins<
  TData = Awaited<ReturnType<typeof searchCoins>>,
  TError = ErrorType<unknown>,
>(
  params: SearchCoinsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof searchCoins>>,
      TError,
      TData
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchCoinsQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get coin market
 * @summary Get coin market
 */
export const getCoinMarket = (
  id: string,
  params?: GetCoinMarketParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetCoinMarket200>(
    { url: `/coins/${id}/market`, method: 'GET', params, signal },
    options,
  )
}

export const getGetCoinMarketQueryKey = (
  id: string,
  params?: GetCoinMarketParams,
) => {
  return [`/coins/${id}/market`, ...(params ? [params] : [])] as const
}

export const getGetCoinMarketQueryOptions = <
  TData = Awaited<ReturnType<typeof getCoinMarket>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: GetCoinMarketParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getCoinMarket>>,
      TError,
      TData
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetCoinMarketQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoinMarket>>> = ({
    signal,
  }) => getCoinMarket(id, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCoinMarket>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetCoinMarketQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCoinMarket>>
>
export type GetCoinMarketQueryError = ErrorType<unknown>

/**
 * @summary Get coin market
 */

export function useGetCoinMarket<
  TData = Awaited<ReturnType<typeof getCoinMarket>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: GetCoinMarketParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getCoinMarket>>,
      TError,
      TData
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetCoinMarketQueryOptions(id, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create user
 * @summary Create user
 */
export const createUser = (
  createUserBody: BodyType<CreateUserBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateUser201>(
    {
      url: `/users`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createUserBody,
      signal,
    },
    options,
  )
}

export const getCreateUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: BodyType<CreateUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: BodyType<CreateUserBody> },
  TContext
> => {
  const mutationKey = ['createUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: BodyType<CreateUserBody> }
  > = props => {
    const { data } = props ?? {}

    return createUser(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>
export type CreateUserMutationBody = BodyType<CreateUserBody>
export type CreateUserMutationError = ErrorType<unknown>

/**
 * @summary Create user
 */
export const useCreateUser = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: BodyType<CreateUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: BodyType<CreateUserBody> },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * List users
 * @summary List users
 */
export const listUsers = (
  params?: ListUsersParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ListUsers200>(
    { url: `/users`, method: 'GET', params, signal },
    options,
  )
}

export const getListUsersQueryKey = (params?: ListUsersParams) => {
  return [`/users`, ...(params ? [params] : [])] as const
}

export const getListUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorType<unknown>,
>(
  params?: ListUsersParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listUsers>>,
      TError,
      TData
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListUsersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({
    signal,
  }) => listUsers(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ListUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof listUsers>>
>
export type ListUsersQueryError = ErrorType<unknown>

/**
 * @summary List users
 */

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorType<unknown>,
>(
  params?: ListUsersParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof listUsers>>,
      TError,
      TData
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getListUsersQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update user
 * @summary Update user
 */
export const updateUser = (
  id: string,
  updateUserBody: BodyType<UpdateUserBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateUser200>(
    {
      url: `/users/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateUserBody,
    },
    options,
  )
}

export const getUpdateUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: string; data: BodyType<UpdateUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: BodyType<UpdateUserBody> },
  TContext
> => {
  const mutationKey = ['updateUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { id: string; data: BodyType<UpdateUserBody> }
  > = props => {
    const { id, data } = props ?? {}

    return updateUser(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>
export type UpdateUserMutationBody = BodyType<UpdateUserBody>
export type UpdateUserMutationError = ErrorType<unknown>

/**
 * @summary Update user
 */
export const useUpdateUser = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: string; data: BodyType<UpdateUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: BodyType<UpdateUserBody> },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options)

  return useMutation(mutationOptions)
}
