/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * Truther API
 * Truther API Documentation
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import type {
  CreateUser201,
  CreateUserBody,
  GetCoinMarket200,
  GetCoinMarketParams,
  GetUser200,
  GetUserBody,
  ListUsers200,
  ListUsersParams,
  SearchCoins200,
  SearchCoinsParams,
  UpdateUser200,
  UpdateUserBody,
} from './model'
import { customInstance } from '../lib/api'
import type { ErrorType, BodyType } from '../lib/api'

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

/**
 * Get user
 * @summary Get user
 */
export const getUser = (
  getUserBody: BodyType<GetUserBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetUser200>(
    {
      url: `/auth`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: getUserBody,
      signal,
    },
    options,
  )
}

export const getGetUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    { data: BodyType<GetUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof getUser>>,
  TError,
  { data: BodyType<GetUserBody> },
  TContext
> => {
  const mutationKey = ['getUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getUser>>,
    { data: BodyType<GetUserBody> }
  > = props => {
    const { data } = props ?? {}

    return getUser(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type GetUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>
export type GetUserMutationBody = BodyType<GetUserBody>
export type GetUserMutationError = ErrorType<unknown>

/**
 * @summary Get user
 */
export const useGetUser = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    { data: BodyType<GetUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof getUser>>,
  TError,
  { data: BodyType<GetUserBody> },
  TContext
> => {
  const mutationOptions = getGetUserMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Search coins
 * @summary Search coins
 */
export const searchCoins = (
  params: SearchCoinsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SearchCoins200>(
    { url: `/coins/search`, method: 'GET', params, signal },
    options,
  )
}

export const getSearchCoinsQueryKey = (params: SearchCoinsParams) => {
  return [`/coins/search`, ...(params ? [params] : [])] as const
}

export const getSearchCoinsQueryOptions = <
  TData = Awaited<ReturnType<typeof searchCoins>>,
  TError = ErrorType<unknown>,
>(
  params: SearchCoinsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchCoins>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSearchCoinsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchCoins>>> = ({
    signal,
  }) => searchCoins(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchCoins>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchCoinsQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchCoins>>
>
export type SearchCoinsQueryError = ErrorType<unknown>

export function useSearchCoins<
  TData = Awaited<ReturnType<typeof searchCoins>>,
  TError = ErrorType<unknown>,
>(
  params: SearchCoinsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchCoins>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchCoins>>,
          TError,
          Awaited<ReturnType<typeof searchCoins>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSearchCoins<
  TData = Awaited<ReturnType<typeof searchCoins>>,
  TError = ErrorType<unknown>,
>(
  params: SearchCoinsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchCoins>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchCoins>>,
          TError,
          Awaited<ReturnType<typeof searchCoins>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSearchCoins<
  TData = Awaited<ReturnType<typeof searchCoins>>,
  TError = ErrorType<unknown>,
>(
  params: SearchCoinsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchCoins>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Search coins
 */

export function useSearchCoins<
  TData = Awaited<ReturnType<typeof searchCoins>>,
  TError = ErrorType<unknown>,
>(
  params: SearchCoinsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchCoins>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSearchCoinsQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get coin market
 * @summary Get coin market
 */
export const getCoinMarket = (
  id: string,
  params?: GetCoinMarketParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetCoinMarket200>(
    { url: `/coins/${id}/market`, method: 'GET', params, signal },
    options,
  )
}

export const getGetCoinMarketQueryKey = (
  id: string,
  params?: GetCoinMarketParams,
) => {
  return [`/coins/${id}/market`, ...(params ? [params] : [])] as const
}

export const getGetCoinMarketQueryOptions = <
  TData = Awaited<ReturnType<typeof getCoinMarket>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: GetCoinMarketParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCoinMarket>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetCoinMarketQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoinMarket>>> = ({
    signal,
  }) => getCoinMarket(id, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCoinMarket>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCoinMarketQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCoinMarket>>
>
export type GetCoinMarketQueryError = ErrorType<unknown>

export function useGetCoinMarket<
  TData = Awaited<ReturnType<typeof getCoinMarket>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params: undefined | GetCoinMarketParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCoinMarket>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCoinMarket>>,
          TError,
          Awaited<ReturnType<typeof getCoinMarket>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCoinMarket<
  TData = Awaited<ReturnType<typeof getCoinMarket>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: GetCoinMarketParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCoinMarket>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCoinMarket>>,
          TError,
          Awaited<ReturnType<typeof getCoinMarket>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetCoinMarket<
  TData = Awaited<ReturnType<typeof getCoinMarket>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: GetCoinMarketParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCoinMarket>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get coin market
 */

export function useGetCoinMarket<
  TData = Awaited<ReturnType<typeof getCoinMarket>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: GetCoinMarketParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCoinMarket>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetCoinMarketQueryOptions(id, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create user
 * @summary Create user
 */
export const createUser = (
  createUserBody: BodyType<CreateUserBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateUser201>(
    {
      url: `/users`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createUserBody,
      signal,
    },
    options,
  )
}

export const getCreateUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: BodyType<CreateUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: BodyType<CreateUserBody> },
  TContext
> => {
  const mutationKey = ['createUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: BodyType<CreateUserBody> }
  > = props => {
    const { data } = props ?? {}

    return createUser(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>
export type CreateUserMutationBody = BodyType<CreateUserBody>
export type CreateUserMutationError = ErrorType<unknown>

/**
 * @summary Create user
 */
export const useCreateUser = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: BodyType<CreateUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: BodyType<CreateUserBody> },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Update user
 * @summary Update user
 */
export const updateUser = (
  updateUserBody: BodyType<UpdateUserBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateUser200>(
    {
      url: `/users`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateUserBody,
    },
    options,
  )
}

export const getUpdateUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { data: BodyType<UpdateUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { data: BodyType<UpdateUserBody> },
  TContext
> => {
  const mutationKey = ['updateUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { data: BodyType<UpdateUserBody> }
  > = props => {
    const { data } = props ?? {}

    return updateUser(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>
export type UpdateUserMutationBody = BodyType<UpdateUserBody>
export type UpdateUserMutationError = ErrorType<unknown>

/**
 * @summary Update user
 */
export const useUpdateUser = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { data: BodyType<UpdateUserBody> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { data: BodyType<UpdateUserBody> },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * List users
 * @summary List users
 */
export const listUsers = (
  params?: ListUsersParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ListUsers200>(
    { url: `/users`, method: 'GET', params, signal },
    options,
  )
}

export const getListUsersQueryKey = (params?: ListUsersParams) => {
  return [`/users`, ...(params ? [params] : [])] as const
}

export const getListUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorType<unknown>,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListUsersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({
    signal,
  }) => listUsers(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof listUsers>>
>
export type ListUsersQueryError = ErrorType<unknown>

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | ListUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorType<unknown>,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorType<unknown>,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List users
 */

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorType<unknown>,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListUsersQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}
